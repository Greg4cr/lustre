package coverage;

import enums.Coverage;
import enums.Polarity;
import types.ExprTypeVisitor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import jkind.lustre.BinaryExpr;
import jkind.lustre.BinaryOp;
import jkind.lustre.Equation;
import jkind.lustre.Expr;
import jkind.lustre.IdExpr;
import jkind.lustre.Node;
import jkind.lustre.UnaryExpr;
import jkind.lustre.VarDecl;
import observability.AffectAtCaptureEquation;
import observability.CombObservedEquation;
import observability.DelayVisitor;
import observability.ObservabilityObligation;
import observability.ObserverVisitor;
import observability.SequentialUsedEquation;
import observability.TokenAction;
import observability.TreeBuilder;
import observability.tree.Tree;
import observability.tree.TreeNode;

public final class ObservabilityCoverage {
	private final Node node;
	private final Coverage coverage;
	private final ExprTypeVisitor exprTypeVisitor;
	private final Polarity polarity;
	private ObservabilityVisitor observabilityVisitor;
	private int count = 0;
	
	private Map<String, List<String>> delayTable = new HashMap<>();
	private Map<String, List<String>> observerTable = new HashMap<>();
	/* <lhs_of_equation, <raw_var_in_rhs, <renamed_var, time_seen>>> */
	private Map<String, Map<String, Map<String, Integer>>> observerArithMap = new HashMap<>();
	/* <lhs_of_equation, <raw_var_in_rhs, <renamed_var, time_seen>>> */
	private Map<String, Map<String, Map<String, Integer>>> delayArithMap = new HashMap<>();
	
	private Map<String, VarDecl> ids = new HashMap<>();
	private List<VarDecl> decls = new ArrayList<>();
	private List<String> strIds = new ArrayList<>();
	private List<String> outputs = new ArrayList<>();
	private List<String> inputs = new ArrayList<>();
	
	private Map<String, Tree> observerTrees = new HashMap<>();
	private Map<String, Tree> delayTrees = new HashMap<>();
	private Map<String, Tree> deadNodeTrees = new HashMap<>();
	private List<String> deadNodes = new ArrayList<>();
	private Map<String, Map<String, Integer>> affectAtCaptureTable = new TreeMap<>();
	private List<String> nonCombObservedSeqRoots = new ArrayList<>();
	
	// dynamic tokens
	private final String prefix = "TOKEN_D";
	private IdExpr[] tokens;
	// relationship of tokens (in sequential trees), Map<Root, Leaves>
	private Map<TreeNode, List<TreeNode>> tokenDepTable = new HashMap<>();
	// token to tree node (root), Map<Token, Node>
	private Map<IdExpr, TreeNode> tokenToNode = new HashMap<>();
	// tree node (root) to token, Map<Node, Token>
	private Map<TreeNode, IdExpr> nodeToToken = new HashMap<>();
	
	private Map<String, List<String>> affectPairs = new HashMap<>();
	
	public ObservabilityCoverage(Node node, Coverage coverage, 
				Polarity polarity, ExprTypeVisitor exprTypeVisitor) {
		this.node = node;
		this.coverage = coverage;
		this.polarity = polarity;
		this.exprTypeVisitor = exprTypeVisitor;
		this.observabilityVisitor = new ObservabilityVisitor(exprTypeVisitor);
		this.count = 0;
		populateMaps();
	}

	public List<Obligation> generate() {
		List<Obligation> obligations = new ArrayList<>();
		
		obligations.addAll(generateNonObservedEquations());
		obligations.addAll(generateObservedEquations());
		
		buildTrees();
		drawTokenMaps();
		drawTokenDependantTable();
		
		obligations.addAll(generateCombObervedEquations());
		obligations.addAll(generateSeqUsedByEquations());
		obligations.addAll(generateTokenActions());
		obligations.addAll(generateAffectAtCaptureEquations()); 
		obligations.addAll(generateObligations());
		
		return obligations;
	}
		
	// generate obligations for observability coverage
	private List<Obligation> generateObservedEquations() {
		List<Obligation> obligations = new ArrayList<>();
		
		// Start generating obligations
		for (Equation equation : node.equations) {
			String id = null;
			
			if (equation.lhs.isEmpty()) {
				id = "EMPTY";
			} else {
				id = equation.lhs.get(0).id;
			}

			// Concatenate IDs with more than one left-hand variables
			for (int i = 1; i < equation.lhs.size(); i++) {
				id += "_" + equation.lhs.get(i);
			}
			
			// A = B; or A = (UnaryOp B);
			if (equation.expr instanceof IdExpr
					|| ((equation.expr instanceof UnaryExpr)
							&& ((UnaryExpr)equation.expr).expr instanceof IdExpr)) {
				observabilityVisitor.setIsDef(true);
			} else {
				observabilityVisitor.setIsDef(false);
			}
			
			// obligations/expressions generated by visitors
			List<Obligation> observabilityObs = equation.expr
					.accept(observabilityVisitor);
			
			HashMap<String, Expr> map = new HashMap<>();
			
			for (Obligation observabilityOb : observabilityObs) {
				if (polarity.equals(Polarity.TRUE)
						&& !observabilityOb.expressionPolarity) {
					continue;
				}
				if (polarity.equals(Polarity.FALSE)
						&& observabilityOb.expressionPolarity) {
					continue;
				}
				
				String lhs = observabilityOb.condition + "_COMB_USED_BY_" + id;
				count++;
				
				Expr expr = observabilityOb.obligation;
				
				if (!map.containsKey(lhs)) {
					map.put(lhs, expr);
				} else if (!map.get(lhs).toString().contains(expr.toString())) {
					expr = new BinaryExpr(map.get(lhs), BinaryOp.OR, expr);
					map.put(lhs, expr);
				}
			}
			
			for (String lhs : map.keySet()) {
				obligations.add(new Obligation(new IdExpr(lhs), true, map.get(lhs)));
			}
			
//			System.out.println(obligations);
		}
				
		return obligations;
	}

	private List<Obligation> generateNonObservedEquations() {
		CoverageVisitor coverageVisitor = null;
		List<Obligation> obligations = new ArrayList<>();
		String property;
		
		switch (coverage) {
		case OMCDC:
			coverageVisitor = new MCDCVisitor(exprTypeVisitor);
			break;
		case OCONDITION:
			coverageVisitor = new ConditionVisitor(exprTypeVisitor);
			break;
		case OBRANCH:
			coverageVisitor = new BranchVisitor(exprTypeVisitor);
			break;
		case ODECISION:
			coverageVisitor = new DecisionVisitor(exprTypeVisitor);
			break;
		default:
			throw new IllegalArgumentException("Incorrect coverage: " + coverage);
		}
		
		for (Equation equation : node.equations) {
			List<Obligation> obs = equation.expr.accept(coverageVisitor);
			
			String id = null;
			/* for rename: <renamedId, timeSeen>*/
			Map<String, Integer> conditions = new TreeMap<>();
			
			if (equation.lhs.isEmpty()) {
				id = "EMPTY";
			} else {
				id = equation.lhs.get(0).id;
			}

			// Concatenate IDs with more than one left-hand variables
			for (int i = 1; i < equation.lhs.size(); i++) {
				id += "_" + equation.lhs.get(i);
			}
			
			// count occurrence of each var (ob.condition) in the equation, for renaming
			for (Obligation ob : obs) {
				if (conditions.containsKey(ob.condition)) {
					conditions.put(ob.condition, conditions.get(ob.condition) + 1);
				} else {
					conditions.put(ob.condition, 1);
				}
			}
			
			HashMap<String, Integer> handledList = new HashMap<>();
			int i;
			
			// generate obligations
			for (Obligation ob : obs) {
				i = 0;
				
				int occ = conditions.get(ob.condition);
					property = ob.condition;
				
					if (occ > 2) {
						if (handledList.containsKey(ob.condition)) {
							i = handledList.get(ob.condition) + 1;
						}
						property = property + "_" + (i / 2);
					}
					
					handledList.put(ob.condition, i);
					
					property = property + "_"
							+ (ob.polarity ? "TRUE" : "FALSE") + "_AT_"
							+ id + "_" + coverage.name() + "_"
							+ (ob.polarity ? "TRUE" : "FALSE");
					
					Obligation currentOb = new Obligation(new IdExpr(property), true, ob.obligation);
					obligations.add(currentOb);
			}
			
			// populate map
//			System.out.println(id + " vs " + conditions);
			affectAtCaptureTable.put(id, conditions);
		}
//		System.out.println("\naffectAtCaptureTable ::: \n" + affectAtCaptureTable);
		
		return obligations;
	}
		
	// generate COMB_OBSERVED expressions
	private List<Obligation> generateCombObervedEquations() {
		CombObservedEquation combObsEquation = new CombObservedEquation(this.observerTrees, 
												this.nonCombObservedSeqRoots, this.deadNodes);
		return combObsEquation.generate();
	}
	
	// generate SEQ_USED_BY expressions
	private List<Obligation> generateSeqUsedByEquations() {
		SequentialUsedEquation delayDepdnEquation = new SequentialUsedEquation(delayTrees);
		return delayDepdnEquation.generate();
	}
	
	// generate TOKEN Actions
	private List<Obligation> generateTokenActions() {
		TokenAction tokenAction = new TokenAction(delayTrees, tokenDepTable, 
											tokenToNode, nodeToToken, tokens);
		
		return tokenAction.generate();
	}
	
	// generate affecting_at_capture expressions
	private List<Obligation> generateAffectAtCaptureEquations() {
		AffectAtCaptureEquation affect = new AffectAtCaptureEquation(delayTrees,
							observerTrees, delayTable, affectAtCaptureTable,
							coverage, tokenDepTable, nodeToToken);
		affect.setDeadNodes(deadNodes);
		affect.setSingleNodeTrees(deadNodeTrees);
		
		List<Obligation> affectObligations = new ArrayList<>();
		affectObligations.addAll(affect.generate());
		
		// get affect pairs for final obligations generation
		affectPairs = affect.getAffectPairs();
//		System.out.println("::: AffectPairs :::");
//		System.out.println(affectPairs);
		
		return affectObligations;
	}
	
	// generate observability obligations for each expression
	private List<Obligation> generateObligations() {
		ObservabilityObligation obligation = new ObservabilityObligation(affectAtCaptureTable, 
																affectPairs, coverage);
		return obligation.generate();
	}
	
	/* ******************************************************
	 * 			utilities
	 * ****************************************************** 
	 */
	
	private void populateMaps() {
		populateIds(ids);
		getStrIds(strIds);
		getOutputs(outputs);
		getInputs(inputs);
		getDecls(decls);
	}
	
	private void buildTrees() {
		populateDelayTable(delayTable);
//		System.out.println("::: delayTable :::");
//		System.out.println(delayTable);
		populateObserverTable(observerTable);
//		System.out.println("::: observerTable :::");
//		System.out.println(observerTable);
		
		populateArithMaps();
		
		TreeBuilder builder = new TreeBuilder(observerArithMap, delayArithMap,
				ids, outputs);
		
		observerTrees = builder.buildObserverTree();
//		System.out.println("::: observer trees :::");
//		for (String root : observerTrees.keySet()) {
//			System.out.println(observerTrees.get(root).convertToList());
//		}
		
		delayTrees = builder.buildDelayTree();
//		System.out.println("::: delay trees :::");
//		for (String root : delayTrees.keySet()) {
//			System.out.println(delayTrees.get(root).convertToList());
//		}
		
		populateNonCombObservedSeqRoots();
//		System.out.println("::: non-combObserved sequential roots :::");
//		System.out.println(this.nonCombObservedSeqRoots);
		
		populateDeadNodes(deadNodes);
		deadNodeTrees = builder.buildDeadRootTree(deadNodes);
//		System.out.println("::: dead trees :::");
//		for (String root : deadNodeTrees.keySet()) {
//			System.out.println(deadNodeTrees.get(root).convertToList());
//		}
	}
	
	private void populateNonCombObservedSeqRoots() {
		for (String seqRoot : delayTrees.keySet()) {
			
			for (String obsRoot : observerTrees.keySet()) {
				Tree obsTree = observerTrees.get(obsRoot);
				
				if (!obsTree.equals(seqRoot) && !obsTree.containsNode(seqRoot)) {
					this.nonCombObservedSeqRoots.add(seqRoot);
				}
			}
		}
		
	}

	private void populateDeadNodes(List<String> deadNodes) {
		List<String> reachedList = new ArrayList<>();
		
		for (String used : observerArithMap.keySet()) {
			reachedList.add(used);
			
			for (String reached : observerArithMap.get(used).keySet()) {
				reachedList.add(reached);
			}
		}
		
		for (String used : delayArithMap.keySet()) {
			reachedList.add(used);
			
			for (String reached : delayArithMap.get(used).keySet()) {
				reachedList.add(reached);
			}
		}
		
		for (String used : strIds) {
			if (inputs.contains(used)) {
				continue;
			}
			if (! reachedList.contains(used)) {
				deadNodes.add(used);
			}
		}
	}
	
	private void populateIds(Map<String, VarDecl> ids) {
		for (VarDecl decl : node.inputs) {
			ids.put(decl.id, decl);
		}
		
		for (VarDecl decl : node.outputs) {
			ids.put(decl.id, decl);
		}
		
		for (VarDecl decl : node.locals) {
			ids.put(decl.id, decl);
		}
	}

	public void getDecls(List<VarDecl> decls) {
		decls.addAll(node.inputs);
		decls.addAll(node.outputs);
		decls.addAll(node.locals);
	}
	
	public void getStrIds(List<String> strIds) {
		for (String id : ids.keySet()) {
			strIds.add(id);
		}
	}

	public void getOutputs(List<String> outputs) {
		for (VarDecl decl : node.outputs) {
			outputs.add(decl.id);
		}
	}
	
	public void getInputs(List<String> inputs) {
		for (VarDecl decl : node.inputs) {
			inputs.add(decl.id);
		}
	}

	private void populateDelayTable(Map<String, List<String>> delayTable) {
		DelayVisitor visitor = new DelayVisitor(exprTypeVisitor);
		
		for (Equation equation : node.equations) {
			String rhs = equation.expr.toString();
//			System.out.println(equation);
			
			if (rhs.contains("pre ") ||
					rhs.contains("PRE ")) {
				List<String> list = new ArrayList();
				list.addAll(equation.expr.accept(visitor));
//				System.out.println("list >>> " + list);
				if (list != null && !list.isEmpty()) {
					delayTable.put(equation.lhs.get(0).id, list);
				}
			}
		}
	}
	
	private void populateObserverTable(Map<String, List<String>> observerTable) {
		ObserverVisitor visitor = new ObserverVisitor(exprTypeVisitor);
		
		for (Equation equation : node.equations) {
			observerTable.put(equation.lhs.get(0).id, equation.expr.accept(visitor));
		}
	}
	
	private Map<String, String> getExprTable() {
		Map<String, String> exprTable = new HashMap<>();
		
		for (Equation equation : node.equations) {
			exprTable.put(equation.lhs.get(0).id, equation.expr.toString());
		}
		
		return exprTable;
	}
	
	private void populateArithMaps() {
		Map<String, String> exprTable = getExprTable();
		
		for (String lhs : observerTable.keySet()) {
			Map<String, Map<String, Integer>> map = new HashMap<>();
			String rhs = exprTable.get(lhs);
			
			for (String id : observerTable.get(lhs)) {
				Map<String, Integer> ariths = new HashMap<>();
				
				for (String arithExpr : Obligation.arithExprByExpr.keySet()) {
					if (rhs.contains(arithExpr) && arithExpr.contains(id)) {
						String arith = Obligation.arithExprByExpr.get(arithExpr);
						if (ariths.containsKey(arith)) {
							ariths.put(arith, ariths.get(arith) + 1);
						} else {
							ariths.put(Obligation.arithExprByExpr.get(arithExpr), 1);
						}
					}
				}
				
				if (ariths.isEmpty()) {
					for (String strId : observerTable.get(lhs)) {
						if (! strId.equals(id)) {
							continue;
						}
						if (ariths.containsKey(id)) {
							ariths.put(id, ariths.get(id) + 1);
						} else {
							ariths.put(id, 1);
						}
					}
				}
				
				map.put(id, ariths);
			}
						
			observerArithMap.put(lhs, map);
		}
		
		for (String lhs : delayTable.keySet()) {
			Map<String, Map<String, Integer>> map = new HashMap<>();
			String rhs = exprTable.get(lhs);
			
			for (String id : delayTable.get(lhs)) {
				Map<String, Integer> ariths = new HashMap<>();
				for (String arithExpr : Obligation.arithExprByExpr.keySet()) {
					if (rhs.contains(arithExpr) && arithExpr.contains(id)) {
						String arith = Obligation.arithExprByExpr.get(arithExpr);
						if (ariths.containsKey(arith)) {
							ariths.put(arith, ariths.get(arith) + 1);
						} else {
							ariths.put(Obligation.arithExprByExpr.get(arithExpr), 1);
						}
					}
				}
				
				if (ariths.isEmpty()) {
					for (String strId : delayTable.get(lhs)) {
						if (! strId.equals(id)) {
							continue;
						}
						if (ariths.containsKey(id)) {
							ariths.put(id, ariths.get(id) + 1);
						} else {
							ariths.put(id, 1);
						}
					}
				}
				map.put(id, ariths);
			}
			delayArithMap.put(lhs, map);
		}
		
//		System.out.println("::: observer map :::\n" + observerArithMap);
//		System.out.println("::: delay map :::\n" + delayArithMap);
	}
	
	public int getTokenRange() {
		return this.delayArithMap.keySet().size();
	}
	
	// build token-to-node, node-to-token maps
	private void drawTokenMaps() {
		tokens = new IdExpr[delayTrees.size()];
		int count = 0;
		
		for (String tree : delayTrees.keySet()) {
			tokens[count] = new IdExpr(prefix + (count + 1));
			TreeNode node = delayTrees.get(tree).root;
			tokenToNode.put(tokens[count], node);
			nodeToToken.put(node, tokens[count]);

			count++;
		}
		
//		System.out.println("token to node:\n" + tokenToNode);
	}
		
	public void drawTokenDependantTable() {
		for (TreeNode node : nodeToToken.keySet()) {
			List<TreeNode> list = new ArrayList<>();
			for (String rootStr : delayTrees.keySet()) {
				Tree delayTree = delayTrees.get(rootStr);
				for (TreeNode child : delayTree.root.children) {
					if (child.containsNode(node.rawId)) {
						list.add(delayTrees.get(rootStr).root);
					}
				}
			}
			tokenDepTable.put(node, list);
		}
	} 
}
